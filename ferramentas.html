<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>Software Defined Networks</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>Software Defined Networks</h1>
        <h2>EEL879 - Redes II - UFRJ 2016.2 </h2>
    
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">

          <h1>Controladores</h1>
            <span style="font-size:18px">
              <p>
                Aplicação em SDN que gerencia o controle de fluxo para permitir uma rede inteligente. São baseados em protocolos, como o OpenFlow, que permitem aos servidores comunicar os <i>switches</i> para onde enviar os pacotes.</p>
              <p>
                O controlador funciona como uma espécie de sistema operacional para a rede. Ao retirar o plano de controle do hardware da rede e executando como software, o controlador facilita o gerenciamento automatizado da rede, facilitando a integração e administração de aplicativos.</p>
              <p>
                A seguir, alguns exemplos de controladores:</p>

              <span>
                <h2 style="margin-left: 30px;"> NOX </h2>
                <p style="margin-left: 25px;">
                  NOX foi o primeiro controlador SDN, desenvolvido inicialmente por Nicira Networks, junto com o OpenFlow. Foi doado para a comunidade SDN <i>open source</i>, virando a base para as próximas soluções de controladores.
                </p> 
                <p style="margin-left: 25px;">
                  Nox é dividido em diferentes linhas de desenvolvimento:
                </p>
                <h3 style="margin-left: 60px;">NOX clássico</h3>
                  <p style="margin-left: 50px;">
                    Versão disponível sob licença pública geral. Suporta as linguagens C++ e <i>Python</i>.
                  </p>
                <h3 style="margin-left: 60px;">NOX: O "Novo NOX"</h3>
                  <p style="margin-left: 50px;">
                    Apenas contém suporte para C++ e possui menos aplicações que o clássico, mas esta versão é mais rápida e possui melhor código base.
                  </p>
                <h3 style="margin-left: 60px;">POX</h3>
                  <p style="margin-left: 50px;">
                    Fornece suporte para <i>Python</i>, é conhecido como "irmão" do NOX. Por permitir desenvolvimentos mais rápido e prototipagem, está sendo mais utilizado que o NOX.
                  </p>
              </span>

              <spam>
                <h2 style="margin-left: 30px;"> Beacon </h2>
                <p style="margin-left: 25px;">
                  Controlador com base em Java, Beacon é um dos mais populares controladores.  
                  Foi o primeiro a possibilitar programadores iniciantes a criarem e trabalharem com ambientes SDN, porém é limitado a topologia de estrela.
                </p>
              </spam>

              <spam>
                <h2 style="margin-left: 30px;"> FloodLight </h2>
                <p style="margin-left: 25px;">
                   Como o Beacon, é um controlador com base em Java, sendo considerado hoje em dia, o mais popular entre os controladores 
                </p>
                 
                <p style="margin-left: 25px;">
                  Podemos dizer que sua popularidade vem da facilidade que os desenvolvedores tem para desenvolver aplicações, dado que elas podem ser construídas utilizando a arquitetura <i>REST</i>.
                </p>
                <p style="margin-left: 25px;">
                  Outra vantagem do FloodLight é a possibilidade de controlar uma rede que contém redes OpenFlow conectadas com redes comuns, não OpenFlow.
                </p>
              </spam>

              <spam>
                <h2 style="margin-left: 30px;"> Open DayLight </h2>
                <p style="margin-left: 25px;">
                   Deriva do design original do Beacon, sendo também com base em Java, o <i>OpenDaylight</i> é capaz de ser implementado em uma variedade de ambientes de rede de produção. Pode suportar uma estrutura de controlador modular e para outros padrões de SDN e protocolos futuros.
                </p>
                <p style="margin-left: 25px;">  
                  Este controlador é implementado somente em <i>software</i>, e é mantido dentro de sua própria máquina virtual Java (JVM). Isto é, pode ser implementado em <i>hardwares</i> e 
                  plataformas com suporte Java. 
                </p>                           
              </spam>

              <spam>
                <h2 style="margin-left: 30px;"> Onos </h2>
                <p style="margin-left: 25px;">
                  É projetado para operar como um cluster de nós que são idênticos em termo de sua pilha de <i>software</i> e pode suportar falhas de nós individuais sem causar interrupções em sua capacidade de controlar a operação da rede.
                </p>
                <p style="margin-left: 25px;">  
                  Enquanto <i>ONOS</i> se inclina fortemente em protocolos e modelos padrão (OpenFlow, <i>NETCONF</i>,...), sua arquitetura de sistema não está diretamente ligada a eles. No lugar, fornece seu próprio conjunto de abstrações e modelos de alto nível.
                </p>                           
              </spam>


            </span>
          <h1>Open vSwitch (OVS)</h1>
            <span style="font-size:18px">
            <p>Como o nome sugere, é um <i>switch</i> virtual com código aberto que implementa o protocolo OpenFLow. Simulando <i>switches</i> em ambientes virtuais, ele permite que máquinas virtuais se comuniquem entre si em um mesmo <i>host</i> ou até mesmo realizar a comunicação com a rede física.</p>
            <p>O OVS é executado como se fosse uma distribuição Linux, porém pode ser utilizado em nível de usuário ao custo de perder desempenho e acesso à alguns recursos. Ele também pode ser executado na maioria das plataformas virtuais, como por exemplo <i>VirtualBox</i>, facilitando assim a realização de testes.</p>
            <p>Atualmente o OVS fornece ao usuário o controle de diversos recursos, entre eles:</p>
              <span >
                <h2 style="margin-left: 30px;"> Recursos para segurança </h2>
                <ul style="margin-left: 30px;">
                  <li><b>VLAN</b></li>
                  <li><b>Isolamento</b></li>
                  <li><b><i>Firewall</i></b></li>
                  <li><b>Tunelamento</b></li>
                </ul>
              </span>

              <span>
                <h2 style="margin-left: 30px;"> Recursos para Monitoramento </h2>
                <ul style="margin-left: 30px;">
                  <li><b>Netflow</b></li>
                  <li><b>sFlow</b></li>
                  <li><b>SPAN</b></li>
                  <li><b>RSPAN</b></li>
                </ul>
              </span>

              <span >
                <h2 style="margin-left: 30px;"> Recursos para QoS </h2>
                <ul style="margin-left: 30px;">
                  <li><b>Modelagem de tráfego</b></li>
                  <li><b>Enfileiramento de tráfego</b></li>
                </ul>
              </span>

            </span>
          <h1>FlowVisor</h1>
            <span style="font-size:18px">
              <p>O FlowVisor não passa de um controlador OpenFlow que tem como principal característica atuar como um <i>middleware</i> entre os <i>switches</i> e os outros controladores OpenFlow.
              Todas as mensagens que são trocadas entre <i>switches</i> e o controlador são transmitidas por ele.</p>
              <p> A sua principal função é dividir a rede entre os outros controladores OpenFlow de maneira a garantir  o isolamento entre as divisões, ou seja, ele deve garantir que cada controlador só possa ter visão e controle sobre seu pedaço da rede. Essa divisão pode ser feita de diversas maneira como por exemplo utilizando os endereços IP ou portas TCP</p>
            </span>

          <h1>Openflow</h1>
            <span style="font-size:18px">
		<h2>A necessidade de redes programáveis </h2>
		<p> Redes são parte crítica da vida humana. Devido à enorme quantidade de equipamentos instalados, e ao número de protocolos existentes, estas são de tal modo ossificadas que tornou-se difícil testar novas ideias, como, por exemplo, novos protocolos. Como resultado, a maioria das novas ideias da comunidade de pesquisa acaba não sendo devidamente testada, nunca adquirindo a confiança necessária para sua propagação.</p>
		<p> Então, o conceito de redes programáveis emergiu. Estas exigem comutadores e roteadores programáveis, que podem processar pacotes para múltiplas redes experimentais simultaneamente, através da virtualização. </p>
		<p> A maioria dos equipamentos de rede são proprietários (havendo pouca padronização) e, em geral, os vendedores não se interessam por disponibilizar uma plataforma aberta e programável para seus comutadores e roteadores, de modo que pesquisadores possam implantar novos protocolos. </p>
		<p> A intenção do comutador Openflow é resolver estes problemas através da flexibilidade, possuindo 4 objetivos principais:
		<ul>
			<li> passível de alto desempenho com baixos custos de implementação </li>
			<li> capaz de suportar uma ampla gama de pesquisa </li>
			<li> capaz de separar o tráfego de experimentos do de produção </li>
			<li> consistente com a necessidade de vendedores para plataformas fechadas </li>
		</ul>
		</p>
		<h2> O comutador OpenFlow </h2>
		<p> Como a maioria dos equipamentos Ethernet modernos contêm tabelas de fluxo, o Openflow usa isso para implementar serviços, como firewalls, NAT, QoS, além de coletar estatísticas. Ao mesmo tempo em que as tabelas de fluxo variam de vendedor para vendedor, há funções comuns a vários equipamentos distintos, que o Openflow busca utilizar. 
Este é o cerne do Openflow: fornecer um protocolo aberto para programar as tabelas de fluxo em diferentes equipamentos. Isto atende os objetivos:
		<ul>
			<li> O administrador de rede pode particionar o tráfego, separando o experimental do de produção </li>
			<li> Permite a pesquisa ao possibilitar que pesquisadores controlem seus próprios fluxos, ao escolher a rota que seus pacotes devem seguir e o processamento que devem receber </li>
			<li> De uma forma pouco custosa, permite que pesquisadores testem novos protocolos (até substitutos ao IP), modelos de segurança, etc. </li>
		</ul>		
		</p>
		<p> O comutador consiste de, no mínimo, três partes: 
		<ul>
			<li> A tabela de fluxos, que para cada fluxo de entrada (ou seja, pacotes cujos cabeçalhos satisfazem determinadas características) informa ao comutador como o pacote deve ser processado, através de uma série de ações que devem ser executadas </li>
			<li> O chamado Canal Seguro, que conecta o comutador ao controlador (remoto), e que possibilita a troca de pacotes e comandos entre os dois </li>
			<li> O Protocolo Openflow, que padroniza a comunicação entre o controlador e o comutador. É a interface com a qual as tabelas de fluxos podem ser definidas externamente </li>
		</ul>
		</p>
		<p> Cada entrada da tabela associa os pacotes cujos cabeçalhos correspondem a determinadas regras a uma das seguintes ações básicas:
		<ul>
			<li> encaminhar os pacotes a determinada(s) porta(s), que permite o roteamento através da rede </li>
			<li> encapsular e encaminhar os pacotes para o controlador, através do Canal Seguro. Em geral, o primeiro pacote de um determinado fluxo é encaminhado ao controlador para que este decida se deve ser adicionada à tabela uma entrada correspondente ao fluxo </li>
			<li> descartar os pacotes do fluxo (ex. para segurança, bloqueando pacotes de determinadas origens) </li>
		</ul>
		</p>
		<p> As tabelas de fluxo possuem 3 campos:
		<ul>
			<li> cabeçalho dos pacotes que definem o fluxo </li>
			<li> ação associada ao fluxo, que define como os pacotes serão processados </li>
			<li> estatísticas: número de pacotes e bytes em determinado fluxo e o tempo desde o último pacote naquele fluxo (que facilita a remoção de fluxos inativos) </li>
		</ul>
		</p>

		<h2> Protocolo OpenFlow </h2>
		<p> Há 3 tipos de mensagem:
		<ul>
			<li> Controlador para comutador </li>
			<p> São mensagens iniciadas pelo controlador e podem exigir ou não resposta. Como exemplos, o controlador pode:
				<ul>
					<li> requisitar as funcionalidades que o comutador possui </li> 
					<li> perguntar ou determinar as configurações do comutador </li>
					<li> modificar o estado das tabelas de fluxo, adicionando, excluindo, ou modificando as entradas </li>
					<li> ler as estatísticas do comutador </li>
				</ul>
			</p>
			<li> Assíncrona </li>
			<p> São mensagens enviadas pelo comutador sem solicitação por parte do controlador. Como exemplos, o comutador pode avisar o controlador:
				<ul>
					<li> caso um pacote não tenha satisfeito nenhuma regra da primeira tabela de fluxo. Dependendo da configuração do comutador, ao invés de enviar o aviso, pode descartar o pacote ou checar a próxima tabela. </li>
					<li> quando uma entrada da tabela de fluxo for excluída. Isto ocorre, por exemplo, devido às datas de expiração (dependendo ou não de inatividade) </li>
					<li> caso haja algum problema, através da mensagem de erro </li>
				</ul>
			</p>
			<li> Simétrica </li>
			<p> São mensagens enviadas em ambas as direções, sem solicitação prévia. Podem ser mensagens:
				<ul>
					<li> 'hello' (para iniciação de conexão) </li>
					<li> 'echo' (servem para medir a latência, por exemplo) </li>
				</ul>
			</p>
		</ul>
		</p>
            </span>
            </span>

	   	  </section>
        <aside id="sidebar">
          <a href="index.html" class="button" id="resumo">
            <small>SDN</small>
            Resumo
          </a>
          <a href="introducao.html" class="button" id="intro">
            <small>SDN</small>
            Introdução
          </a>
          <a href="conceitos.html" class="button" id="conceitos">
            <small>SDN</small>
            Conceitos
          </a>
          <a href="arquitetura.html" class="button" id="arq">
            <small>SDN</small>
            Arquitetura
          </a>
          <a href="ferramentas.html" class="button" id="ferramentas">
            <small>SDN</small>
            Ferramentas
          </a>
          <a href="aplicacao.html" class="button" id="app">
            <small>SDN</small>
            Aplicações
          </a>
          <a href="seguranca.html" class="button" id="sec">
            <small>SDN</small>
            Segurança
          </a>
          <a href="conclusao.html" class="button" id="conclusao">
            <small>SDN</small>
            Conclusão
          </a>
          <a href="bibliografia.html" class="button" id="biblio">
            <small>SDN</small>
            Bibliografia
          </a>
          <a href="bibliografia.html" class="button" id="perguntas">
            <small>SDN</small>
            Perguntas
          </a>


          <p class="repo-owner"></p>

          <p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>
        </aside>
      </div>
    </div>

  
  </body>
</html>
